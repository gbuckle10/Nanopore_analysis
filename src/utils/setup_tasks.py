import argparse
import platform
import subprocess
from pathlib import Path

from src.utils.runner import load_config, get_project_root, run_external_command, run_wgbstools
import os
import sys
import csv
import requests
import tarfile
import gzip
import shutil
import yaml

project_root = get_project_root()
CONFIG_PATH = os.path.join(project_root, "config.yaml")
RUNTIME_CONFIG_PATH = os.path.join(project_root, "src", "runtime_config.yaml")


def download_file(url, destination):
    print(f"Downloading from {url} to {destination}")

    try:
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            with open(destination, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
    except requests.exceptions.RequestException as e:
        print(f"Error downloading file: {e}", file=sys.stderr)
        sys.exit(1)


def make_directories(config):
    """
    Creates all directories specified in the config file.
    """
    print("--- Creating core directory structure ---")

    for directory in config['paths']['core_directories']:
        abs_path = os.path.join(project_root, directory)
        os.makedirs(abs_path, exist_ok=True)

    with open(RUNTIME_CONFIG_PATH, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write('# Auto-generated by setup_tasks.py. Do not edit manually')
    print(f"Initialised runtime config at {RUNTIME_CONFIG_PATH}")


def setup_submodules(config):
    print(" --- Setting up git submodules. ---")
    if not os.path.exists(f"{project_root}/.gitmodules"):
        print("No gitmodules file found. Skipping submodule setup.")
        return

    repository_path = "/app"

    print(f">>> Configuring Git to trust {repository_path}")
    subprocess.run(
        ['git', 'config', '--global', '--add', 'safe.directory', repository_path]
    )

    print(">>> Getting the list of submodule paths")
    result = subprocess.run(
        ['git', 'submodule--helper', 'list'],
        capture_output=True,
        text=True,
        check=True,
        cwd=repository_path
    )

    submodule_paths = [line.split()[-1] for line in result.stdout.strip().split('\n')]
    print(f">>> Found submodules: {submodule_paths}")

    for path in submodule_paths:
        full_path = os.path.join(repository_path, path)
        print(f">>> Configuring Git to trust submodule at {full_path}")
        subprocess.run(
            ['git', 'config', '--global', '--add', 'safe.directory', full_path]
        )

    sync_command = ["git", "submodule", "sync", "--recursive"]
    update_command = ["git", "submodule", "update", "--init", "--recursive", "--force"]

    run_external_command(sync_command)
    run_external_command(update_command)

    print("Compiling wgbstools")

    comp_command = ["python", "install.py"]
    # run_external_command(comp_command, cwd=wgbstools_dir)

    # The code block below will write the config file with the wgbstools dir in the config.
    # Wait until config/template config is properly set up to use this block.
    '''
    wgbstools_dir = f"{project_root}/externals/wgbs_tools"
    config['paths']['tools']['wgbstools'] = wgbstools_dir
    config_path = project_root / "config.yaml"
    with open(config_path, 'w') as f:
        yaml.dump(config, f, sort_keys=False, indent=2)
    '''

    uxm_dir = f"{project_root}/externals/UXM_deconv"
    uxm_exe_path = os.path.abspath(os.path.join(uxm_dir, "src/uxm.py"))
    with open(RUNTIME_CONFIG_PATH, 'a') as f:
        f.write(f'export UXM_EXE="{uxm_exe_path}"\n')
    print(f"uxm path added to {RUNTIME_CONFIG_PATH}")


def download_atlas_manifest_files(config):
    print("--- Downloading and preparing atlas files and manifests ---")
    atlas_dir = os.path.join(project_root, "data/atlas")
    os.makedirs("data/atlas", exist_ok=True)

    files_to_download = {
        "illumina_manifest.csv": "https://webdata.illumina.com/downloads/productfiles/humanmethylation450/humanmethylation450_15017482_v1-2.csv",
        "full_atlas.csv": "https://github.com/nloyfer/meth_atlas/raw/refs/heads/master/full_atlas.csv.gz",
        "UXM_atlas.tsv": "https://raw.githubusercontent.com/nloyfer/UXM_deconv/refs/heads/main/supplemental/Atlas.U25.l4.hg19.tsv"
    }

    for filename, url in files_to_download.items():
        dest_path = os.path.join(atlas_dir, filename)
        if not os.path.exists(dest_path):
            download_file(url, dest_path)
        else:
            print(f"{filename} already exists. Skipping download.")

    gz_path = os.path.join(atlas_dir, "full_atlas.csv.gz")
    csv_path = os.path.join(atlas_dir, "full_atlas.csv")
    if os.path.exists(gz_path) and not os.path.exists(csv_path):
        print("Decompressing full_atlas.csv.gz...")
        with gzip.open(gz_path, 'rb') as f_in:
            with open(csv_path, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)

    # Convert UXM_atlas.tsv to .csv
    tsv_path = os.path.join(atlas_dir, "UXM_atlas.tsv")
    uxm_csv_path = os.path.join(atlas_dir, "UXM_atlas.csv")
    if os.path.exists(tsv_path) and not os.path.exists(uxm_csv_path):
        print("Converting UXM_atlas.tsv to UXM_atlas.csv")
        with open(tsv_path, 'r') as tsv_file, open(uxm_csv_path, 'w', newline='') as csv_file:
            reader = csv.reader(tsv_file, delimiter='\t')
            writer = csv.writer(uxm_csv_path, delimiter=',')
            for row in reader:
                writer.writerow(row)


def download_and_index_reference_genome_manual(config):
    """
    Downloads the reference genomes with AWS CLI and indexes it with minimap 2.
    """
    genome = config['paths']['reference_genome']
    print(f"--- Setting up reference genome {genome} ---")

    ref_dir = os.path.join(project_root, 'reference_genomes', genome)
    os.makedirs(ref_dir, exist_ok=True)
    ref_fasta = os.path.join(ref_dir, config['paths']['reference_genome_fasta_name'])
    ref_mmi = os.path.join(ref_dir, config['paths']['indexed_ref_gen_fasta_name'])

    if not os.path.exists(ref_fasta):
        # Maybe we'll hardcode the reference genome urls in this function...
        ref_url = config['paths']['reference_genome_url']
        print(f"Reference file {ref_fasta} doesn't exist. Downloading from {ref_url}")
        run_external_command([
            "aws", "c3", "cp", ref_url, ref_fasta, "--no-sign-request"
        ])
    else:
        print("Reference genome already exists.")

    if not os.path.exists(ref_mmi):
        print("Indexing reference genome with minimap2...")
        run_external_command([
            "minimap2", "-d", ref_mmi, ref_fasta
        ])
    else:
        print(f"Reference genome index already exists.")

def download_and_index_reference_genome(config):
    """
    Use wgbstools init_genome to initialise the specified genome.
    """
    genome = config['paths']['reference_genome']
    print(f"Initialising reference genome {genome}")
    wgbstools_cmd = [
        "wgbstools", "init_genome",
        genome
    ]

    run_wgbstools(wgbstools_cmd)

def install_dorado(config):
    """
    Downloads and extracts the correct version of Dorado.
    """
    print(" --- Setting up Dorado ---")
    version = config['parameters']['setup']['dorado_version']
    system = platform.system()

    archive_filename = f"dorado-{version}-linux-x64.tar.gz"
    download_url = f"https://cdn.oxfordnanoportal.com/software/analysis/dorado-{version}-linux-x64.tar.gz"

    dorado_dir = f"{project_root}/tools/dorado-{version}"

    print(f"Checking for dorado at {dorado_dir}")

    if os.path.isdir(dorado_dir):
        print(f"Dorado already found at {dorado_dir}. Writing to config.yaml and skipping download.")
        dorado_exe_path = os.path.abspath(os.path.join(dorado_dir, "bin", "dorado"))
        return dorado_exe_path
    else:
        print(f"Downloading dorado version {version} from {download_url}")
        archive_path = os.path.join(project_root, "tools", archive_filename)
        download_file(download_url, archive_path)

        print(f"Extracting {archive_path}...")
        with tarfile.open(archive_path, "r:gz") as tar:
            tar.extractall(path="tools")

        os.remove(archive_path)
        print("Extraction complete")

    dorado_exe_path = os.path.abspath(os.path.join(dorado_dir, "bin", "dorado"))
    print(f"The dorado executable path is {dorado_exe_path}")

    return dorado_exe_path


def add_args(parser):
    """Add setup-specific args to the parser"""
    parser.add_argument(
        "--dorado-version",
        type=str,
        help="Dorado version to download."
    )
    parser.add_argument(
        '-c', '--config',
        default='config.yaml',
        type=Path,
        help="Path to the config file."
    )
    subparsers = parser.add_subparsers(dest='command', help="Installation task to run")
    parser.set_defaults(command='all') # If no command is given, default to all.

    all_parser = subparsers.add_parser('all', help="Run all installation steps (default)")
    all_parser.add_argument('--dorado-version', help='Override Dorado version from config file.')

    tool_parser = subparsers.add_parser('tools', help="Install/update command-line tools (e.g. Dorado)")
    tool_parser.add_argument('--dorado-version', help='Override Dorado version from config file.')

    subparsers.add_parser('submodules', help="Initialise/update Git submodules.")

    return parser


def parse_args(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(
        description="Setup for pipeline run"
    )
    parser = add_args(parser)
    args = parser.parse_args(argv)
    return args


def main(argv=None):
    args = parse_args(argv)

    print(f">>> Loading configurations")

    config = load_config(args.config)

    # If dorado version is in args, override config
    if args.dorado_version is not None:
        print(f"Overriding config with user-defined dorado version '{args.dorado_version}'")
        config['parameters']['setup']['dorado_version'] = args.dorado_version

    # Load existing runtime_config, otherwise make a new one.
    try:
        with open('runtime_config.yaml', 'r') as f:
            runtime_config = yaml.safe_load(f)
    except FileNotFoundError:
        runtime_config = {}

    if args.command in ['all', 'tools']:
        tool_paths = install_dorado(config)
        print(f"The dorado executable path is {tool_paths}. We will add it to runtime_config.yaml")
        runtime_config.setdefault('tools', {}).update(tool_paths)
        print(f"Added. Runtime config is now {runtime_config}")

    if args.command in ['all', 'submodules']:
        submodule_paths = setup_submodules(config)
        runtime_config.setdefault('submodules', {}).update(submodule_paths)

    print(">>> Writing update runtime_config.yaml...")
    with open('runtime_config.yaml', 'w') as f:
        yaml.dump(runtime_config, f, sort_keys=False)

    print("Internal setup task completed.")

    if args.dorado_version is not None:
        print(f"Overriding dorado version with user-provided version. Using {args.dorado_version} instead.")
        config['parameters']['setup']['dorado_version'] = args.dorado_version

    # Run methods
    make_directories(config)
    setup_submodules(config)
    download_atlas_manifest_files(config)
    # download_and_index_reference_genome(config)

    if config['pipeline_control']['run_setup_tasks']['download_fast5_data']:
        download_fast5_data(config)
    if config['pipeline_control']['run_setup_tasks']['convert_fast5_to_pod5']:
        convert_fast5_to_pod5(config)


if __name__ == "__main__":
    main()
